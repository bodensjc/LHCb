#define dp_cuts_cxx
#include "dp_cuts.h"
#include <TH2.h>
#include <TStyle.h>
#include "scripts/fit1MeV_Gaussian.C"

//**************** Definition Section **************
TH1 * phicuthist = NULL;
TH1 * phicutbadhist = NULL;

TH1 * totalcuthist = NULL;
TH1 * totalcutrejects = NULL;


TH1 * myDpFitHist = NULL;
TF1 * myDpFit = NULL;

double_t phiupperbound = 1.063899417;//bounds created by +-12MeV of phi mass 
double_t philowerbound = 1.014965577;//of 1019.455 then squared to match mkpkm


TH1 * probprodhist = NULL;



void dp_cuts::Begin(TTree * /*tree*/)
{
   TString option = GetOption();

//************** Initialization Section ************
   phicuthist = new TH1D("phi cut","D^{+} #rightarrow K^{+}K^{-}#pi^{+} Cut on #phi(1020)", 100, 1819,1919);
   phicuthist->GetXaxis()->SetTitle("D^{+} Mass [MeV/c^{2}]");
   phicuthist->GetYaxis()->SetTitle("Events per MeV");
   phicuthist->SetMinimum(0);

   phicutbadhist = new TH1D("phi cut rejects","D^{+} #rightarrow K^{+}K^{-}#pi^{+} Cut on #phi(1020) REJECTS", 100, 1819,1919);
   phicutbadhist->GetXaxis()->SetTitle("D^{+} Mass [MeV/c^{2}]");
   phicutbadhist->GetYaxis()->SetTitle("Events per MeV");
   phicutbadhist->SetMinimum(0);

   myDpFit = new TF1("myDpFit",fit1MeV_Gaussian, 1819, 1919, 5);
   myDpFit->SetParNames("p0", "mean", "width", "lin_b", "lin_m");
    myDpFit->SetParameter(0,100000.);
    myDpFit->SetParameter(1,1869);
    myDpFit->SetParameter(2,4.);
    myDpFit->SetParLimits(2,0.,20.);
    myDpFit->SetParameter(3,1000);
    myDpFit->SetParameter(4,0.);



    probprodhist = new TH1D("probprodhist", "ProbNN k,k,pi Product for K^{+} K^{-} #pi^{+}", 100, 0, 1);



   totalcuthist = new TH1D("D^{+} cuts","D^{+} #rightarrow K^{+}K^{-}#pi^{+} Cut on #phi(1020), log(probNN), and IP #chi^{2}", 100, 1819,1919);
   totalcuthist->GetXaxis()->SetTitle("D^{+} Mass [MeV/c^{2}]");
   totalcuthist->GetYaxis()->SetTitle("Events per MeV/c^{2}");
   totalcuthist->SetMinimum(0);

   totalcutrejects = new TH1D("D^{+} cut rejects","D^{+} #rightarrow K^{+}K^{-}#pi^{+} Cut on #phi(1020), log(probNN), and IP #chi^{2} - REJECTS", 100, 1819,1919);
   totalcutrejects->GetXaxis()->SetTitle("D^{+} Mass [MeV/c^{2}]");
   totalcutrejects->GetYaxis()->SetTitle("Events per MeV/c^{2}");
   totalcutrejects->SetMinimum(0);


}



void dp_cuts::SlaveBegin(TTree * /*tree*/) {}



Bool_t dp_cuts::Process(Long64_t entry)
{
   fReader.SetLocalEntry(entry);
   GetEntry(entry);
//*************** Loop Section ********************
   //filling the actual Lorentz Vectors
   TLorentzVector kpLV(*Kplus_PX, *Kplus_PY, *Kplus_PZ, *Kplus_PE);
   TLorentzVector kmLV(*Kminus_PX, *Kminus_PY, *Kminus_PZ, *Kminus_PE);
   TLorentzVector piLV(*Piplus_PX, *Piplus_PY, *Piplus_PZ, *Piplus_PE);
   //initializing the Lorentz Vectors for pairing
   TLorentzVector kpkmLV(kpLV + kmLV);
   TLorentzVector kppiLV(kpLV + piLV);
   TLorentzVector kmpiLV(kmLV + piLV);
   //calculating invariant mass pairs
   double_t mkpkm = kpkmLV.Mag2()/1000000;
   double_t mkppi = kppiLV.Mag2()/1000000;
   double_t mkmpi = kmpiLV.Mag2()/1000000;


   //probability stuff
   double_t kminusprobk = *Kminus_MC15TuneV1_ProbNNk;
   double_t kplusprobk = *Kplus_MC15TuneV1_ProbNNk;
   double_t piplusprobpi = *Piplus_MC15TuneV1_ProbNNpi;
   double_t probprod = kminusprobk*kplusprobk*piplusprobpi;
   double_t kminusprobpi = *Kminus_MC15TuneV1_ProbNNpi;
   double_t kplusprobpi = *Kplus_MC15TuneV1_ProbNNpi;
   double_t piplusprobk = *Piplus_MC15TuneV1_ProbNNk;
   //calculating the logdifs (needs to be larger than 5)
   double_t kminuslog = TMath::Log(kminusprobk) - TMath::Log(kminusprobpi);
   double_t kpluslog = TMath::Log(kplusprobk) - TMath::Log(kplusprobpi);
   double_t pipluslog = TMath::Log(piplusprobpi) - TMath::Log(piplusprobk);


   Bool_t phicutpass = (mkpkm > philowerbound && mkpkm < phiupperbound);//KK invariant mass pair ut on phi1020 resonance
   Bool_t probcutpass = (kminuslog > 5 && kpluslog > 5 && pipluslog > 0);//5, 5, 0 comes from section 3 of the paper saved in slack
   Bool_t ipchi2cutpass = (*Dplus_IPCHI2_OWNPV < 5);//not sure what exactly IPchi2 is... 


   if (mkpkm > philowerbound && mkpkm < phiupperbound) {
     phicuthist->Fill(*Dplus_M);
   }
   if (mkpkm <= philowerbound || mkpkm >= phiupperbound) {
     phicutbadhist->Fill(*Dplus_M);
   }


   if (phicutpass && probcutpass && ipchi2cutpass) {
     totalcuthist->Fill(*Dplus_M);
   } else {
     totalcutrejects->Fill(*Dplus_M);
   }




   return kTRUE;
}



void dp_cuts::SlaveTerminate() {}



void dp_cuts::Terminate()
{
 //**************** Wrap-up Section ****************
auto phican = new TCanvas("phican","phican",1600,800);
 phican->Divide(2,1);
 phican->cd(1);
 phicuthist->Fit("myDpFit");
 phicuthist->Draw();
 phican->cd(2);
 phicutbadhist->Draw();
 phican->SaveAs("image/dp_phicut.png");



 auto totalcan = new TCanvas("totalcan", "totalcan", 1600, 800);
 totalcan->Divide(2,1);
 totalcan->cd(1);
 totalcan->SetLeftMargin(0.5);
 totalcuthist->Fit("myDpFit");
 totalcuthist->Draw();
 totalcan->cd(2);
 totalcutrejects->Draw();
 totalcan->SaveAs("image/dp_totalcut.png");




}
