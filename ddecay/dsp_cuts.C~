#define dsp_cuts_cxx
#include "dsp_cuts.h"
#include <TH2.h>
#include <TStyle.h>
#include "scripts/fit1MeV_Gaussian.C"

//**************Definition Section**************
TH1 * phicuthist = NULL;
TH1 * phicutbadhist = NULL;

TH1 * myDspFitHist = NULL;
TF1 * myDspFit = NULL;

double_t phiupperbound = 1.063899417;//bounds created by +-12MeV of phi mass 
double_t philowerbound = 1.014965577;//of 1019.455 then squared to match mkpkm



void dsp_cuts::Begin(TTree * /*tree*/)
{
   TString option = GetOption();
//**************Initialization Section***************
   phicuthist = new TH1D("phi cut","D^{+}_{s} #rightarrow K^{+}K^{-}#pi^{+} Cut on #phi(1020)", 100, 1919,2019);
   phicuthist->GetXaxis()->SetTitle("D^{+}_{s} Mass [MeV/c^{2}]");
   phicuthist->GetYaxis()->SetTitle("Events per MeV");
   phicuthist->SetMinimum(0);

   phicutbadhist = new TH1D("phi cut rejects","D^{+}_{s} #rightarrow K^{+}K^{-}#pi^{+} Cut on #phi(1020) REJECTS", 100, 1919,2019);
   phicutbadhist->GetXaxis()->SetTitle("D^{+}_{s} Mass [MeV/c^{2}]");
   phicutbadhist->GetYaxis()->SetTitle("Events per MeV");
   phicutbadhist->SetMinimum(0);

   myDspFit = new TF1("myDspFit",fit1MeV_Gaussian, 1919, 2019, 5);
   myDspFit->SetParNames("p0", "mean", "width", "lin_b", "lin_m");
    myDspFit->SetParameter(0,100000.);
    myDspFit->SetParameter(1,1969);
    myDspFit->SetParameter(2,4.);
    myDspFit->SetParLimits(2,0.,20.);
    myDspFit->SetParameter(3,1000);
    myDspFit->SetParameter(4,0.);





}

void dsp_cuts::SlaveBegin(TTree * /*tree*/) {}

Bool_t dsp_cuts::Process(Long64_t entry)
{
   fReader.SetLocalEntry(entry);
   GetEntry(entry);
   //******************Loop Section****************
   //filling the actual Lorentz Vectors
   TLorentzVector kpLV(*Kplus_PX, *Kplus_PY, *Kplus_PZ, *Kplus_PE);
   TLorentzVector kmLV(*Kminus_PX, *Kminus_PY, *Kminus_PZ, *Kminus_PE);
   TLorentzVector piLV(*Piplus_PX, *Piplus_PY, *Piplus_PZ, *Piplus_PE);
   //initializing the Lorentz Vectors for pairing
   TLorentzVector kpkmLV(kpLV + kmLV);
   TLorentzVector kppiLV(kpLV + piLV);
   TLorentzVector kmpiLV(kmLV + piLV);
   //calculating invariant mass pairs
   double_t mkpkm = kpkmLV.Mag2()/1000000;
   double_t mkppi = kppiLV.Mag2()/1000000;
   double_t mkmpi = kmpiLV.Mag2()/1000000;

   if (mkpkm > philowerbound && mkpkm < phiupperbound) {
     phicuthist->Fill(*D_splus_M);
   }
   else {
     phicutbadhist->Fill(*D_splus_M);
   }











   return kTRUE;
}

void dsp_cuts::SlaveTerminate() {}

void dsp_cuts::Terminate()
{
  //*******************Wrap-Up Section********************

auto phican = new TCanvas("phican","phican",1600,800);


 phican->Divide(2,1);
 phican->cd(1);
 phicuthist->Fit("myDspFit");
 phicuthist->Draw();
 phican->cd(2);
 phicutbadhist->Fit("myDspFit");
 phicutbadhist->Draw();
 phican->SaveAs("image/dsp_phicut.png");





}
